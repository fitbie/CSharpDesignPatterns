using System.Collections;

namespace GOF.Iterator
{
    /// <summary>
    /// .NET has greatest Iterator implementation - <see cref="IEnumerator"/> iterator interface, which is exposed by <see cref="IEnumerable"/> (and the generics).<br/>
    /// The classic implementation is done by either separate iterator object, who accept some data collection as argument, or mixin (C++) class.
    /// .NET offers opportunity to implement separate iterator and then return it from collection's <see cref="IEnumerable.GetEnumerator"/> implementation, 
    /// or use IEnumerator autogenerated by <see langword="yield"/> statement.
    /// </summary>
    public class IteratorPattern
    {
        public static void Iterate()
        {
            LinkedListNode<int> root = new(5, new(2, new(4, new(1, new(3)))));
            foreach (var value in root)
            {
                Console.WriteLine(value);
            }
        }
    }


    // C# modern implementation via explicit IEnumerable and generic vision. 
    // We're using linked-list-alike structure as example here.
    public class LinkedListNode<T> : IEnumerable<T>, IEnumerable
    {
        public T Value { get; init; }
        public LinkedListNode<T>? Next { get; }

        public LinkedListNode(T val, LinkedListNode<T>? next = null)
        {
            Value = val;
            Next = next;
        }

        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

        public IEnumerator<T> GetEnumerator()
        {
            return new LinkedListEnumerator<T>(this);

            /* 
            Alternatively (and better to) use yield statement, which generating IEnumerator class and return new instance of it for you automatically.
            
            for (LinkedListNode<T>? current = this; current != null; current = current.Next)
            {
                yield return current.Value;
            }
            */
        }

    }


    // Separate enumerator object implementation
    public class LinkedListEnumerator<T> : IEnumerator<T>
    {
        private LinkedListNode<T> head;
        private LinkedListNode<T>? currentNode;
        private T? current;

        object IEnumerator.Current => Current!;
        public T Current => current!;


        public LinkedListEnumerator(LinkedListNode<T> head)
        {
            this.head = head;
            currentNode = head;
        }


        public bool MoveNext()
        {
            if (currentNode == null) return false;

            current = currentNode.Value;
            currentNode = currentNode.Next;   
            return true;
        }


        public void Reset()
        {
           currentNode = head;
        }


        public void Dispose() {}
    }
}